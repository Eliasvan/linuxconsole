$Id$

Programming gameport drivers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. A basic classic gameport
~~~~~~~~~~~~~~~~~~~~~~~~~~~

If the gameport doesn't provide more than the inb()/outb() functionality,
the code needed to register it with the joystick drivers is simple:

struct gameport gameport;

gameport.io = MY_IO_ADDRESS;
gameport_register_port(&gameport);

Make sure struct gameport is initialized to 0 in all other fields. The
gameport generic code will take care of the rest.

If your hardware supports more than one io address, and your driver can
choose which one program the hardware to, starting from the more exotic
addresses is preferred, because the likelyhood of clashing with the standard
0x201 address is smaller.

Eg. if your driver supports addresses 0x200, 0x208, 0x210 and 0x218, then
0x218 would be the address of first choice.

If your hardware supports a gameport address that is not mapped to ISA io
space (is above 0x1000), use that one, and don't map the ISA mirror.

Also, always request_region() on the whole io space occupied by the
gameport. Although only one ioport is really used, the gameport usually
occupies from one to sixteen addresses in the io space.

2. Memory mapped gameport
~~~~~~~~~~~~~~~~~~~~~~~~~

When a gameport can be accessed through MMIO, this way is preferred, because
it is faster, allowing more reads per second. Registering such a gameport
isn't as easy as a basio IO one, but not so much complex:

struct gameport gameport;

void my_trigger(struct gameport *gameport)
{
	my_mmio = 0xff;
}

unsigned char my_read(struct gameport *gameport)
{
	return my_mmio;	
}

gameport.read = my_read;
gameport.trigger = my_trigger;
gameport_register_port(&gameport);

3. Cooked mode gameport
~~~~~~~~~~~~~~~~~~~~~~~

There are gameports that can report the axis values as numbers, that means
the driver doesn't have to measure them the old way - an ADC is built into
the gameport. To register a cooked gameport:

struct gameport gameport;

int my_cooked_read(struct gameport *gameport, int *axes, int *buttons)
{
	int i;

	for (i = 0; i < 4; i++)
		axes[i] = my_mmio[i];
	buttons[i] = my_mmio[4];
}

int my_open(struct gameport *gameport, int mode)
{
	return -(mode != GAMEPORT_MODE_COOKED);
}

gameport.cooked_read = my_cooked_read;
gameport.open = my_open;
gameport_register_port(&gameport);

4. More complex gameports
~~~~~~~~~~~~~~~~~~~~~~~~~

Gameports can support both raw and cooked modes. In that case combine either
examples 1+2 or 1+3. Gameports can support internal calibration - see
lightning.c on how that works. If your driver supports more than one
gameport, use the ->private member of the gameport struct to point to your
data.

5. Unregistering a gameport
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Simple:

gameport_unregister_port(&gameport);


Enjoy!
